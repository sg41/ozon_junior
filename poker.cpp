/**
 * Колода состоит из 52 карт. Каждая карта обозначается одним из тринадцати
 * значений ( 2, 3, 4, 5, 6, 7, 8, 9, T (Ten), J (Jack), Q (Queen), K (King), A
 * (Ace)) и одной из четырех мастей (S (Spades), C (Clubs), D (Diamonds), H
 * (Hearts)).
 *
 * Выдуманная игра 3-Покер происходит следующим образом:
 * 1. Изначально все игроки получают по две карты из колоды.
 * 2. После этого на стол выкладывается одна карта из той же колоды.
 * 3. Выигрывают те игроки, у которых собралась самая старшая комбинация.
 *
 * Для определения самой старшей комбинации, которая собралась у i-го игрока,
 * используются следующие правила:
 *   - если две карты у игрока в руке и карта на столе имеют одинаковое
 * значение, игрок собрал комбинацию 'Сет со значением x';
 *   - если из двух карт у игрока в руке и карты на столе можно выбрать две
 * карты с одинаковым значением x, игрок собрал комбинацию 'Пара со значением
 * x';
 *   - иначе, берется карта с самым старшим значением из двух карт у игрока в
 * руке и карты на столе, тогда игрок собрал комбинацию 'Старшая карта x'.
 *
 * Любой сет старше пары, а любая пара старше комбинации старшая карта. Из
 * одинаковых комбинаций старше та, у которой старше значение. Если одинаковая
 * самая старшая комбинация есть у нескольких игроков, все они объявляются
 * выигрывшими.
 *
 * Вы — первый игрок. Вам известно, какие карты получил на руки каждый игрок.
 * Определите, какую карту можно выложить на стол, чтобы вы оказались в числе
 * победителей.
 *
 * Входные данные
 * Каждый тест состоит из нескольких наборов входных данных. Первая строка
 содержит
 * целое число t (1≤t≤10^3) — количество наборов входных данных. Далее следует
 * описание наборов входных данных.
 *
 * Первая строка каждого набора входных данных содержит целое число n (2≤n≤25) —
 * количество игроков.
 *
 * Следующие n строк каждого набора входных данных содержат описания двух карт,
 * разделенных пробелом — карты, которые получил на руки i-й игрок.
 *
 * Описание карты состоит из двух символов, записанных подряд: значения и масти.
 *
 * Выходные данные
 * Для каждого набора входных данных выведите в первой строке количество карт k,
 * которые можно выложить на стол для вашей победы. В следующих k строках
 выведите
 * описания этих карт. Выводить описания можно в любом порядке.
 *
 * Разберем первый пример.
 * В первом наборе входных данных для победы первого игрока можно выложить на
 стол
 * десятку (T), тогда первый игрок выиграет с комбинацией сет со значением T.
 * Во втором наборе входных данных невозможно добиться победы первого игрока.
 * В третьем наборе входных данных для победы первого игрока можно выложить на
 стол
 * семерку (7), тогда первый игрок выиграет с комбинацией пара со значением 7.
 * В четвертом наборе входных данных невозможно добиться победы первого игрока.
 * Пример теста 1
 * Входные данные
 * 4
 * 2
 * TS TC
 * AD AH
 * 3
 * 2H 3H
 * 9S 9C
 * 4D QS
 * 3
 * 4C 7H
 * 4H 4D
 * 6S 6H
 * 3
 * 2S 3H
 * 2C 2D
 * 3C 3D
 * Выходные данные
 * 2
 * TD
 * TH
 * 0
 * 3
 * 7S
 * 7C
 * 7D
 * 0
 */

#include <iostream>
#include <map>
#include <set>
#include <utility>
#include <vector>

using Players = std::vector<std::pair<std::string, std::string>>;
using Cards = std::set<std::string>;

std::map<int, int> kRating = {
    {'A', 14}, {'K', 13}, {'Q', 12}, {'J', 11}, {'T', 10}, {'9', 9}, {'8', 8},
    {'7', 7},  {'6', 6},  {'5', 5},  {'4', 4},  {'3', 3},  {'2', 2},
};

bool check_winner(const std::string& card, const Players& hands) {
  std::set<std::pair<int, int>> winners{};
  for (int i = 0; i < hands.size(); i++) {
    if (hands[i].first[0] == hands[i].second[0] &&
        hands[i].first[0] == card[0]) {
      winners.insert(std::make_pair(300 + kRating[hands[i].first[0]], i));
      continue;
    }
    if (hands[i].first[0] == hands[i].second[0] ||
        hands[i].first[0] == card[0]) {
      winners.insert(std::make_pair(200 + kRating[hands[i].first[0]], i));
      continue;
    }
    if (hands[i].second[0] == card[0]) {
      winners.insert(std::make_pair(200 + kRating[hands[i].second[0]], i));
      continue;
    }
    int max_card =
        std::max(kRating[hands[i].first[0]], kRating[hands[i].second[0]]);
    max_card = std::max(max_card, kRating[card[0]]);
    winners.insert(std::make_pair(max_card, i));
  }
  bool result = false;
  auto winner = *winners.rbegin();
  if (winner.second == 0) {
    result = true;
  } else {
    for (auto w = winners.rbegin();
         w != winners.rend() && w->first == winner.first; w++) {
      if (w->second == 0) {
        result = true;
        break;
      }
    }
  }
  return result;
}

int main(void) {
  Cards deck{"AS", "2S", "3S", "4S", "5S", "6S", "7S", "8S", "9S", "TS", "JS",
             "QS", "KS", "AH", "2H", "3H", "4H", "5H", "6H", "7H", "8H", "9H",
             "TH", "JH", "QH", "KH", "AD", "2D", "3D", "4D", "5D", "6D", "7D",
             "8D", "9D", "TD", "JD", "QD", "KD", "AC", "2C", "3C", "4C", "5C",
             "6C", "7C", "8C", "9C", "TC", "JC", "QC", "KC"};
  int t, n;
  std::cin >> t;
  std::vector<Players> hands(t);
  std::vector<Cards> deck_copy(t, deck);
  for (int j = 0; j < t; j++) {
    std::cin >> n;
    hands[j].resize(n);
    for (int i = 0; i < n; i++) {
      std::cin >> hands[j][i].first >> hands[j][i].second;
      deck_copy[j].erase(hands[j][i].first);
      deck_copy[j].erase(hands[j][i].second);
    }
  }

  for (int i = 0; i < t; i++) {
    std::vector<std::string> win_deck{};
    for (auto card : deck_copy[i]) {
      if (check_winner(card, hands[i])) {
        win_deck.push_back(card);
      }
    }
    std::cout << win_deck.size() << std::endl;
    for (auto card : win_deck) {
      std::cout << card << std::endl;
    }
  }
  return 0;
}