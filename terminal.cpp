/**
 * Условие задачи
 * Реализуйте элемент функциональности простейшего терминала.
 *
 * Изначально терминал содержит одну пустую строку, в начале которой находится
 * курсор.
 *
 * Ваша программа должна уметь обрабатывать последовательность символов (строку
 * ввода). Обработка символа зависит от его значения:
 * - Строчная буква латинского алфавита или цифра обозначает, что
 * соответствующий символ вставляется в положение курсора. Курсор сдвигается на
 * позицию после вставленного символа.
 * - Буквы L и R обозначают нажатия стрелок влево и вправо. Они перемещают
 * курсор на одну позицию влево или вправо. Если в соответствующем направлении
 * нет символа, то операция игнорируется. Заметьте, что курсор в любом случае
 * остаётся в той же строке.
 * - Буквы U и D обозначают нажатия стрелок вверх и вниз. Они перемещают курсор
 * на одну позицию вверх или вниз. Если в соответствующем направлении нет
 * строки, то операция игнорируется. Если строка есть, но в ней нужная позиция
 * не существует, то курсор встаёт в конец строки.
 * - Буквы B и E обозначают нажатия клавиш Home и End. Они перемещают курсор в
 * начало или в конец текущей строки.
 * - Буква N обозначает нажатие клавиши Enter — происходит вставка новой строки.
 *   Если курсор находился не в конце текущей строки, то она разрывается, и
 * часть после курсора переносится в новую строку. Курсор после этой операции
 * стоит в начале новой строки.
 *
 * Вы можете представлять себе, что эмулируете последовательность нажатий в
 * простейшем текстовом редакторе, в котором курсор занимает позицию между двумя
 * символами строки (или находится в начале или конце строки).
 *
 * Например, если строка ввода имеет вид otLLLrRuEe256LLLN, то в результате
 * получится две строки:
 * - route
 * - 256
 *
 * Промоделируйте последовательность действий и выведите результат.
 * Входные данные
 * В первой строке входных данных записано целое число t (1≤t≤100) — количество
 * наборов входных данных.
 *
 * Наборы входных данных в тесте независимы. Друг на друга они никак не влияют.
 *
 * Каждый набор входных данных состоит из одной непустой строки
 * —последовательности символов для обработки. Гарантируется, что длина этой
 * строки не превосходит 50. Допустимые символы в строке — строчные буквы
 * латинского алфавита, цифры и буквы L, R, U, D, B, E, N.
 *
 * Выходные данные
 * Для каждого набора входных данных выведите итоговую последовательность строк.
 * Выводите все строки, включая пустые. После каждого набора выходных данных
 * выведите дополнительную строку с единственным символом - (минус).
 *
 * Пример теста 1
 * Входные данные
 *
 * 4
 * otLLLrRuEe256LLLN
 * LRLUUDE
 * itisatest
 * abNcdLLLeUfNxNx
 *
 * Выходные данные
 *
 * route
 * 256
 * -
 * -
 * itisatest
 * -
 * af
 * x
 * xb
 * ecd
 * -
 */

#include <iostream>
#include <string>
#include <vector>
int main(void) {
  int n;
  std::cin >> n;
  std::string in[n];
  for (int i = 0; i < n; i++) {
    std::cin >> in[i];
  }
  for (auto str : in) {
    std::vector<std::string> out(1, "");
    int l = 0, p = 0;
    for (int i = 0; i < str.size(); i++) {
      if ((str[i] >= 'a' && str[i] <= 'z') ||
          (str[i] >= '0' && str[i] <= '9')) {
        out[l].insert(p++, 1, str[i]);
      }
      if (str[i] == 'L' && p > 0) p--;
      if (str[i] == 'R' && p < out[l].size()) p++;
      if (str[i] == 'B') p = 0;
      if (str[i] == 'E') p = out[l].size();
      if (str[i] == 'U' && l > 0) {
        l--;
        if (p > out[l].size()) p = out[l].size();
      }
      if (str[i] == 'D' && l < out.size() - 1) {
        l++;
        if (p > out[l].size()) p = out[l].size();
      }
      if (str[i] == 'N') {
        if (p < out[l].size()) {
          out.insert(out.begin() + l + 1, out[l].substr(p));
          out[l].erase(p);
        } else {
          out.insert(out.begin() + l + 1, "");
        }
        l++;
        p = 0;
      }
    }
    for (auto o_str : out) {
      std::cout << o_str << "\n";
    }
    std::cout << "-\n";
  }
}